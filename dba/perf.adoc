= 性能调优
:toc: manual

== 硬件因素

* 内存（RAM）的读写速度时普通 SSD 的 25 倍。MongoDB 中依赖 RAM 最多的操作包括：聚合、索引遍历、写操作、查询引擎、连接

.*常见存储的IOPS*
|===
|类型 | IOPS

|7200 rpm SATA
|75 - 100

|15000 rpm SAS
|175 - 210

|SSD Intel X25-E(SLC)
|5000

|SSD Intel X25-M G2(MLC) 
|8000

|Amazon EBS
|100

|Amazon EBS Provisioned
|2000

|Amazon EBS Provisioned IOPS(SSD)
|3000

|FusionIO
|135 000

|Violin Memory 6000
|1 000 000
|===

== 数据落盘过程

首先，MongoDB 在存储信息时使用压缩，MongoDB 存储引擎将数据存储到磁盘时使用压缩算法，这个对性能有很重要的影响，因为它降低了磁盘操作的 IO，同时也节省了 CPU 使用时间。

image:img/mongod-data-to-disk.png[]

其次，数据在存储到磁盘之前是在内存中保存，那么如何数据从内存中落盘过程中数据的一致性？MongoDB 提供了两种途径：

. 内部持久化机制 - 一个周期性运行的内部程序周期性的将数据写入/同步到磁盘(A periodical internal process that regulates how data be flushed and synced in to data file)。在持久化机制刷盘的过程中，恢复日志（Journal）是一个必需的组件，它确保因为系统掉电或者崩溃时导致内存数据丢失问题，MongoDB 会先把数据更新写入到 Journal Buffer 里面，然后再更新内存数据，然后再返回给应用端。Journal 会以 100ms 的间隔批量刷到盘上。这样的情况下，即使出现断电数据尚未保存到文件，由于有 Journal 文件的存在，MongoDB 会自动根据 Journal 里面的操作历史记录来对数据文件重新进行追加。Journal 的刷盘是批量，基于压缩的格式进行的。关系型数据库（MySQL， PostgreSQL，Oracle 等）里都有一个Write Ahead Log（Redo Log）做同样的事情，MongoDB 的恢复日志（Journal）相当于关系数据库中的 WAL 日志。
. 外部写关注（Write Concern) - 写关注是 MongoDB 特有的一个功能，它可以让你灵活地指定你写操作的持久化设定。这是一个在性能和可靠性之间的一个权衡，如果设定一个较强的可靠性配置，如：{w: “majority”} 和 {j:1}，那么极端情况下 MongoDB 丢数据的可能性为 0。

最后，数据在磁盘上是一文件的形式保存，根据上面描述，磁盘上文件主要有三类：数据文件、索引文件、恢复日志（Journal）文件。

image:img/mongod-disk-files.png[]

=== 使用directoryperdb、wiredTigerDirectoryForIndexes 增加吞吐量

[source, bash]
.*directoryperdb*
----
$ mongod --dbpath ~/data/db --logpath ~/data/db/mongod.log --fork --directoryperdb
$ mongo hello --eval 'db.myCollections.insert({name: "hello"})'

$ ls data/db/hello/
collection-8-6275239857016906202.wt  index-9-6275239857016906202.wt
----

[source, bash]
.*wiredTigerDirectoryForIndexes*
----
$ mongod --dbpath ~/data/db --logpath ~/data/db/mongod.log --fork --directoryperdb --wiredTigerDirectoryForIndexes
$ mongo hello --eval 'db.myCollections.insert({name: "hello"})'

$ ls -LR data/db/hello/
data/db/hello/:
collection  index

data/db/hello/collection:
8-6326041135875266620.wt

data/db/hello/index:
9-6326041135875266620.wt
----

=== 压缩（compression）

MongoDB 4.2 支持 3 种压缩算法：

|===
|名称 |说明

|snappy
|

|zstd
|

|zlib
|
|===

=== journal

journal 确保数据写磁盘过程中的一致性。那么 journal 详细工作原理是什么？

TODO--

== MongoDB 索引

=== 单字段索引(Single Field Indexes)

MongoDB 数据库中所提供的最简单索引，它的创建语法：

[source, javascript]
----
db.<collection>.createIndex({<field>: <direction>})
----

下载 people.json (链接: https://pan.baidu.com/s/1ZEbXIU3NXcToT5-xNQY83g 提取码: 3wvd) 导入到 MongoDB

[source, javascript]
----
$ mongoimport --host 127.0.0.1:27000 --db test --collection people --drop --file ~/Downloads/people.json
----

[source, javascript]
.*1. 没有索引查询，查看执行计划*
----
var r = db.people.find({"ssn": "720-38-5636"}).explain("executionStats")

r.queryPlanner.winningPlan
{
	"stage" : "COLLSCAN",
	"filter" : {
		"ssn" : {
			"$eq" : "720-38-5636"
		}
	},
	"direction" : "forward"
}

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 1,
	"executionTimeMillis" : 24,
	"totalKeysExamined" : 0,
	"totalDocsExamined" : 50474,
	"executionStages" : {
		"stage" : "COLLSCAN",
		"filter" : {
			"ssn" : {
				"$eq" : "720-38-5636"
			}
		},
		"nReturned" : 1,
		"executionTimeMillisEstimate" : 20,
		"works" : 50476,
		"advanced" : 1,
		"needTime" : 50474,
		"needYield" : 0,
		"saveState" : 394,
		"restoreState" : 394,
		"isEOF" : 1,
		"invalidates" : 0,
		"direction" : "forward",
		"docsExamined" : 50474
	}
}
----

NOTE: queryPlanner 部分 winningPlan stage 为 COLLSCAN，即查询是通过全集合扫描完成；executionStats 部分 nReturned 显示查询结果返回文档总数为 1，totalDocsExamined 属性显示扫描文档的总数为 50474，即执行了全集合扫描。

[source, javascript]
.*2. 创建索引*
----
db.people.createIndex({ssn: 1})
{
	"createdCollectionAutomatically" : false,
	"numIndexesBefore" : 1,
	"numIndexesAfter" : 2,
	"ok" : 1
}
----

[source, javascript]
.*3. 有索引查询，查看执行计划*
----
var r = db.people.find({"ssn": "720-38-5636"}).explain("executionStats")

r.queryPlanner.winningPlan
{
	"stage" : "FETCH",
	"inputStage" : {
		"stage" : "IXSCAN",
		"keyPattern" : {
			"ssn" : 1
		},
		"indexName" : "ssn_1",
		"isMultiKey" : false,
		"multiKeyPaths" : {
			"ssn" : [ ]
		},
		"isUnique" : false,
		"isSparse" : false,
		"isPartial" : false,
		"indexVersion" : 2,
		"direction" : "forward",
		"indexBounds" : {
			"ssn" : [
				"[\"720-38-5636\", \"720-38-5636\"]"
			]
		}
	}
}

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 1,
	"executionTimeMillis" : 3,
	"totalKeysExamined" : 1,
	"totalDocsExamined" : 1,
	"executionStages" : {
		"stage" : "FETCH",
		"nReturned" : 1,
		"executionTimeMillisEstimate" : 0,
		"works" : 2,
		"advanced" : 1,
		"needTime" : 0,
		"needYield" : 0,
		"saveState" : 0,
		"restoreState" : 0,
		"isEOF" : 1,
		"invalidates" : 0,
		"docsExamined" : 1,
		"alreadyHasObj" : 0,
		"inputStage" : {
			"stage" : "IXSCAN",
			"nReturned" : 1,
			"executionTimeMillisEstimate" : 0,
			"works" : 2,
			"advanced" : 1,
			"needTime" : 0,
			"needYield" : 0,
			"saveState" : 0,
			"restoreState" : 0,
			"isEOF" : 1,
			"invalidates" : 0,
			"keyPattern" : {
				"ssn" : 1
			},
			"indexName" : "ssn_1",
			"isMultiKey" : false,
			"multiKeyPaths" : {
				"ssn" : [ ]
			},
			"isUnique" : false,
			"isSparse" : false,
			"isPartial" : false,
			"indexVersion" : 2,
			"direction" : "forward",
			"indexBounds" : {
				"ssn" : [
					"[\"720-38-5636\", \"720-38-5636\"]"
				]
			},
			"keysExamined" : 1,
			"seeks" : 1,
			"dupsTested" : 0,
			"dupsDropped" : 0,
			"seenInvalidated" : 0
		}
	}
}
----

NOTE: 注意: queryPlanner 部分 winningPlan stage 为 FETCH，而 inputStage 的 stage 为 IXSCAN，即查询是通过索引完成；executionStats 部分 nReturned 显示查询结果返回文档总数为 1，totalDocsExamined 属性显示扫描文档的总数为 1，即通过索引获取。

*对比有索引和无索引下执行计划的不同*

|===
|对比项 |无索引 |有索引

|`queryPlanner.winningPlan.stage`
|COLLSCAN
|FETCH

|`queryPlanner.winningPlan.inputStage.stage`
|
|IXSCAN

|`executionStats.nReturned`
|1
|1

|`executionStats.executionTimeMillis`
|24
|1

|`executionStats.totalKeysExamined`
|0
|1

|`executionStats.totalDocsExamined`
|50474
|1

|`executionStats.executionStages.stage`
|COLLSCAN
|FETCH

|`executionStats.executionStages.inputStage.stage`
|
|IXSCAN
|===

[source, javascript]
.*4. 查询一定范围内多个文档，查看执行计划是否命中索引*
----
var r = db.people.find({"ssn": {$gte: "555-00-0000", $lt: "556-00-0000"}}).explain("executionStats")

 r.queryPlanner.winningPlan
{
	"stage" : "FETCH",
	"inputStage" : {
		"stage" : "IXSCAN",
		"keyPattern" : {
			"ssn" : 1
		},
		"indexName" : "ssn_1",
		"isMultiKey" : false,
		"multiKeyPaths" : {
			"ssn" : [ ]
		},
		"isUnique" : false,
		"isSparse" : false,
		"isPartial" : false,
		"indexVersion" : 2,
		"direction" : "forward",
		"indexBounds" : {
			"ssn" : [
				"[\"555-00-0000\", \"556-00-0000\")"
			]
		}
	}
}

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 49,
	"executionTimeMillis" : 1,
	"totalKeysExamined" : 49,
	"totalDocsExamined" : 49,
	"executionStages" : {
		"stage" : "FETCH",
		"nReturned" : 49,
		"executionTimeMillisEstimate" : 0,
		"works" : 50,
		"advanced" : 49,
		"needTime" : 0,
		"needYield" : 0,
		"saveState" : 0,
		"restoreState" : 0,
		"isEOF" : 1,
		"invalidates" : 0,
		"docsExamined" : 49,
		"alreadyHasObj" : 0,
		"inputStage" : {
			"stage" : "IXSCAN",
			"nReturned" : 49,
			"executionTimeMillisEstimate" : 0,
			"works" : 50,
			"advanced" : 49,
			"needTime" : 0,
			"needYield" : 0,
			"saveState" : 0,
			"restoreState" : 0,
			"isEOF" : 1,
			"invalidates" : 0,
			"keyPattern" : {
				"ssn" : 1
			},
			"indexName" : "ssn_1",
			"isMultiKey" : false,
			"multiKeyPaths" : {
				"ssn" : [ ]
			},
			"isUnique" : false,
			"isSparse" : false,
			"isPartial" : false,
			"indexVersion" : 2,
			"direction" : "forward",
			"indexBounds" : {
				"ssn" : [
					"[\"555-00-0000\", \"556-00-0000\")"
				]
			},
			"keysExamined" : 49,
			"seeks" : 1,
			"dupsTested" : 0,
			"dupsDropped" : 0,
			"seenInvalidated" : 0
		}
	}
}
----

NOTE: range 查询可以命中索引，`executionStats.totalKeysExamined` 和 `executionStats.totalDocsExamined` 相同，都为 49，`executionStats.executionStages.stage` 为 FETCH，`executionStats.executionStages.inputStage.stage` 为 IXSCAN。 

[source, javascript]
.*5. 查询一个集合内多个文档，查看执行计划是否命中索引*
----
var r = db.people.find({"ssn": {$in: ["001-29-9184", "177-45-0950", "265-67-9973"]}}).explain("executionStats")

r.queryPlanner.winningPlan
{
	"stage" : "FETCH",
	"inputStage" : {
		"stage" : "IXSCAN",
		"keyPattern" : {
			"ssn" : 1
		},
		"indexName" : "ssn_1",
		"isMultiKey" : false,
		"multiKeyPaths" : {
			"ssn" : [ ]
		},
		"isUnique" : false,
		"isSparse" : false,
		"isPartial" : false,
		"indexVersion" : 2,
		"direction" : "forward",
		"indexBounds" : {
			"ssn" : [
				"[\"001-29-9184\", \"001-29-9184\"]",
				"[\"177-45-0950\", \"177-45-0950\"]",
				"[\"265-67-9973\", \"265-67-9973\"]"
			]
		}
	}
}

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 3,
	"executionTimeMillis" : 3,
	"totalKeysExamined" : 6,
	"totalDocsExamined" : 3,
	"executionStages" : {
		"stage" : "FETCH",
		"nReturned" : 3,
		"executionTimeMillisEstimate" : 0,
		"works" : 6,
		"advanced" : 3,
		"needTime" : 2,
		"needYield" : 0,
		"saveState" : 0,
		"restoreState" : 0,
		"isEOF" : 1,
		"invalidates" : 0,
		"docsExamined" : 3,
		"alreadyHasObj" : 0,
		"inputStage" : {
			"stage" : "IXSCAN",
			"nReturned" : 3,
			"executionTimeMillisEstimate" : 0,
			"works" : 6,
			"advanced" : 3,
			"needTime" : 2,
			"needYield" : 0,
			"saveState" : 0,
			"restoreState" : 0,
			"isEOF" : 1,
			"invalidates" : 0,
			"keyPattern" : {
				"ssn" : 1
			},
			"indexName" : "ssn_1",
			"isMultiKey" : false,
			"multiKeyPaths" : {
				"ssn" : [ ]
			},
			"isUnique" : false,
			"isSparse" : false,
			"isPartial" : false,
			"indexVersion" : 2,
			"direction" : "forward",
			"indexBounds" : {
				"ssn" : [
					"[\"001-29-9184\", \"001-29-9184\"]",
					"[\"177-45-0950\", \"177-45-0950\"]",
					"[\"265-67-9973\", \"265-67-9973\"]"
				]
			},
			"keysExamined" : 6,
			"seeks" : 3,
			"dupsTested" : 0,
			"dupsDropped" : 0,
			"seenInvalidated" : 0
		}
	}
}
----

NOTE: $in 查询可以命中索引，`executionStats.totalKeysExamined` 为 6，`executionStats.totalDocsExamined` 为 3，`executionStats.executionStages.stage` 为 FETCH，`executionStats.executionStages.inputStage.stage` 为 IXSCAN。

[source, javascript]
.*6. 查询一个集合内多个文档，及多个其他属性，查看执行计划是否命中索引*
----
var r = db.people.find({"ssn": {$in: ["001-29-9184", "177-45-0950", "265-67-9973"]}, last_name: {$gte: "H"}}).explain("executionStats")

r.queryPlanner.winningPlan
{
	"stage" : "FETCH",
	"filter" : {
		"last_name" : {
			"$gte" : "H"
		}
	},
	"inputStage" : {
		"stage" : "IXSCAN",
		"keyPattern" : {
			"ssn" : 1
		},
		"indexName" : "ssn_1",
		"isMultiKey" : false,
		"multiKeyPaths" : {
			"ssn" : [ ]
		},
		"isUnique" : false,
		"isSparse" : false,
		"isPartial" : false,
		"indexVersion" : 2,
		"direction" : "forward",
		"indexBounds" : {
			"ssn" : [
				"[\"001-29-9184\", \"001-29-9184\"]",
				"[\"177-45-0950\", \"177-45-0950\"]",
				"[\"265-67-9973\", \"265-67-9973\"]"
			]
		}
	}
}

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 2,
	"executionTimeMillis" : 0,
	"totalKeysExamined" : 6,
	"totalDocsExamined" : 3,
	"executionStages" : {
		"stage" : "FETCH",
		"filter" : {
			"last_name" : {
				"$gte" : "H"
			}
		},
		"nReturned" : 2,
		"executionTimeMillisEstimate" : 0,
		"works" : 6,
		"advanced" : 2,
		"needTime" : 3,
		"needYield" : 0,
		"saveState" : 0,
		"restoreState" : 0,
		"isEOF" : 1,
		"invalidates" : 0,
		"docsExamined" : 3,
		"alreadyHasObj" : 0,
		"inputStage" : {
			"stage" : "IXSCAN",
			"nReturned" : 3,
			"executionTimeMillisEstimate" : 0,
			"works" : 6,
			"advanced" : 3,
			"needTime" : 2,
			"needYield" : 0,
			"saveState" : 0,
			"restoreState" : 0,
			"isEOF" : 1,
			"invalidates" : 0,
			"keyPattern" : {
				"ssn" : 1
			},
			"indexName" : "ssn_1",
			"isMultiKey" : false,
			"multiKeyPaths" : {
				"ssn" : [ ]
			},
			"isUnique" : false,
			"isSparse" : false,
			"isPartial" : false,
			"indexVersion" : 2,
			"direction" : "forward",
			"indexBounds" : {
				"ssn" : [
					"[\"001-29-9184\", \"001-29-9184\"]",
					"[\"177-45-0950\", \"177-45-0950\"]",
					"[\"265-67-9973\", \"265-67-9973\"]"
				]
			},
			"keysExamined" : 6,
			"seeks" : 3,
			"dupsTested" : 0,
			"dupsDropped" : 0,
			"seenInvalidated" : 0
		}
	}
}
----

NOTE: 索引前缀查询同样可以命中索引，查询可以命中索引，`executionStats.totalKeysExamined` 和 `executionStats.totalDocsExamined` 相同，都为 49，`executionStats.executionStages.stage` 为 FETCH，`executionStats.executionStages.inputStage.stage` 为 IXSCAN。

MongoDB 中 sort 排序操作通常需要基于索引键进行，如果 queryPlanner 不能够获取索引键，那么排序会在内存中进行。

* sort 排序基于索引基于索引键性能优于基于非索引键
* 如果 sort 排序不基于索引键，那么排序使用的内存不能超过 32 MB
* 如果升序或降序的单字段索引存在，那么 sort 排序可以是任意方向

基于如下 7, 8, 9 步，执行 `db.people.find({}, {_id: 0, last_name: 1, first_name: 1, ssn: 1}).sort({ssn: 1})`, 对比无索引，升序索引、降序索引：

|===
|对比项 |无索引 |升序索引 |降序索引

|`executionStats.nReturned`
|50474
|50474
|50474

|`executionStats.executionTimeMillis`
|222
|114
|124

|`executionStats.totalKeysExamined`
|0
|50474
|50474

|`executionStats.totalDocsExamined`
|50474
|50474
|50474

|`executionStats.executionStages.stage`
|PROJECTION
|PROJECTION
|PROJECTION

|`executionStats.executionStages.inputStage.stage`
|SORT
|FETCH
|FETCH

|`executionStats.executionStages.inputStage.inputStage.stage`
|SORT_KEY_GENERATOR
|IXSCAN
|IXSCAN

|`executionStats.executionStages.inputStage.inputStage.inputStage.stage`
|COLLSCAN
|
|

|`executionStats.executionStages.inputStage.inputStage.direction`
|
|forward
|backward

|`xecutionStats.executionStages.inputStage.inputStage.keysExamined`
|
|50474
|50474
|===

[source, javascript]
.*7. 以索引的属性进行升序排序，并查看执行计划，预期结果，排序使用了索引排序*
----
var r = db.people.find({}, {_id: 0, last_name: 1, first_name: 1, ssn: 1}).sort({ssn: 1}).explain("executionStats")

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 50474,
	"executionTimeMillis" : 116,
	"totalKeysExamined" : 50474,
	"totalDocsExamined" : 50474,
	"executionStages" : {
		"stage" : "PROJECTION",
		"nReturned" : 50474,
		"executionTimeMillisEstimate" : 98,
		"works" : 50475,
		"advanced" : 50474,
		"needTime" : 0,
		"needYield" : 0,
		"saveState" : 395,
		"restoreState" : 395,
		"isEOF" : 1,
		"invalidates" : 0,
		"transformBy" : {
			"_id" : 0,
			"last_name" : 1,
			"first_name" : 1,
			"ssn" : 1
		},
		"inputStage" : {
			"stage" : "FETCH",
			"nReturned" : 50474,
			"executionTimeMillisEstimate" : 76,
			"works" : 50475,
			"advanced" : 50474,
			"needTime" : 0,
			"needYield" : 0,
			"saveState" : 395,
			"restoreState" : 395,
			"isEOF" : 1,
			"invalidates" : 0,
			"docsExamined" : 50474,
			"alreadyHasObj" : 0,
			"inputStage" : {
				"stage" : "IXSCAN",
				"nReturned" : 50474,
				"executionTimeMillisEstimate" : 33,
				"works" : 50475,
				"advanced" : 50474,
				"needTime" : 0,
				"needYield" : 0,
				"saveState" : 395,
				"restoreState" : 395,
				"isEOF" : 1,
				"invalidates" : 0,
				"keyPattern" : {
					"ssn" : 1
				},
				"indexName" : "ssn_1",
				"isMultiKey" : false,
				"multiKeyPaths" : {
					"ssn" : [ ]
				},
				"isUnique" : false,
				"isSparse" : false,
				"isPartial" : false,
				"indexVersion" : 2,
				"direction" : "forward",
				"indexBounds" : {
					"ssn" : [
						"[MinKey, MaxKey]"
					]
				},
				"keysExamined" : 50474,
				"seeks" : 1,
				"dupsTested" : 0,
				"dupsDropped" : 0,
				"seenInvalidated" : 0
			}
		}
	}
}
----

[source, javascript]
.*8. 删除索引，以非索引的属性进行升序排序，并查看执行计划，预期结果，排序使用了内存排序*
----
db.people.dropIndex({ssn: 1})

var r = db.people.find({}, {_id: 0, last_name: 1, first_name: 1, ssn: 1}).sort({ssn: 1}).explain("executionStats")

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 50474,
	"executionTimeMillis" : 217,
	"totalKeysExamined" : 0,
	"totalDocsExamined" : 50474,
	"executionStages" : {
		"stage" : "PROJECTION",
		"nReturned" : 50474,
		"executionTimeMillisEstimate" : 198,
		"works" : 100952,
		"advanced" : 50474,
		"needTime" : 50477,
		"needYield" : 0,
		"saveState" : 795,
		"restoreState" : 795,
		"isEOF" : 1,
		"invalidates" : 0,
		"transformBy" : {
			"_id" : 0,
			"last_name" : 1,
			"first_name" : 1,
			"ssn" : 1
		},
		"inputStage" : {
			"stage" : "SORT",
			"nReturned" : 50474,
			"executionTimeMillisEstimate" : 162,
			"works" : 100952,
			"advanced" : 50474,
			"needTime" : 50477,
			"needYield" : 0,
			"saveState" : 795,
			"restoreState" : 795,
			"isEOF" : 1,
			"invalidates" : 0,
			"sortPattern" : {
				"ssn" : 1
			},
			"memUsage" : 19977871,
			"memLimit" : 33554432,
			"inputStage" : {
				"stage" : "SORT_KEY_GENERATOR",
				"nReturned" : 50474,
				"executionTimeMillisEstimate" : 57,
				"works" : 50477,
				"advanced" : 50474,
				"needTime" : 2,
				"needYield" : 0,
				"saveState" : 795,
				"restoreState" : 795,
				"isEOF" : 1,
				"invalidates" : 0,
				"inputStage" : {
					"stage" : "COLLSCAN",
					"nReturned" : 50474,
					"executionTimeMillisEstimate" : 21,
					"works" : 50476,
					"advanced" : 50474,
					"needTime" : 1,
					"needYield" : 0,
					"saveState" : 795,
					"restoreState" : 795,
					"isEOF" : 1,
					"invalidates" : 0,
					"direction" : "forward",
					"docsExamined" : 50474
				}
			}
		}
	}
}
----

[source, javascript]
.*9. 创建升续索引，以索引的属性进行降序排序，并查看执行计划，预期结果*
----
db.people.createIndex({ssn: -1})

var r = db.people.find({}, {_id: 0, last_name: 1, first_name: 1, ssn: 1}).sort({ssn: -1}).explain("executionStats")

r.executionStats
{
	"executionSuccess" : true,
	"nReturned" : 50474,
	"executionTimeMillis" : 123,
	"totalKeysExamined" : 50474,
	"totalDocsExamined" : 50474,
	"executionStages" : {
		"stage" : "PROJECTION",
		"nReturned" : 50474,
		"executionTimeMillisEstimate" : 110,
		"works" : 50475,
		"advanced" : 50474,
		"needTime" : 0,
		"needYield" : 0,
		"saveState" : 396,
		"restoreState" : 396,
		"isEOF" : 1,
		"invalidates" : 0,
		"transformBy" : {
			"_id" : 0,
			"last_name" : 1,
			"first_name" : 1,
			"ssn" : 1
		},
		"inputStage" : {
			"stage" : "FETCH",
			"nReturned" : 50474,
			"executionTimeMillisEstimate" : 99,
			"works" : 50475,
			"advanced" : 50474,
			"needTime" : 0,
			"needYield" : 0,
			"saveState" : 396,
			"restoreState" : 396,
			"isEOF" : 1,
			"invalidates" : 0,
			"docsExamined" : 50474,
			"alreadyHasObj" : 0,
			"inputStage" : {
				"stage" : "IXSCAN",
				"nReturned" : 50474,
				"executionTimeMillisEstimate" : 23,
				"works" : 50475,
				"advanced" : 50474,
				"needTime" : 0,
				"needYield" : 0,
				"saveState" : 396,
				"restoreState" : 396,
				"isEOF" : 1,
				"invalidates" : 0,
				"keyPattern" : {
					"ssn" : -1
				},
				"indexName" : "ssn_-1",
				"isMultiKey" : false,
				"multiKeyPaths" : {
					"ssn" : [ ]
				},
				"isUnique" : false,
				"isSparse" : false,
				"isPartial" : false,
				"indexVersion" : 2,
				"direction" : "forward",
				"indexBounds" : {
					"ssn" : [
						"[MaxKey, MinKey]"
					]
				},
				"keysExamined" : 50474,
				"seeks" : 1,
				"dupsTested" : 0,
				"dupsDropped" : 0,
				"seenInvalidated" : 0
			}
		}
	}
}
----

=== 复合索引(Compound Indexes)

MongoDB 数据库中复合索引及索引基于多个字段，它的创建语法：

[source, javascript]
----
db.<collection>.createIndex({<field1>: <type>, <field2>: <type2>, ...})
----

如下是关于复合索引需要注意的地方：

* 复合索引最多可以基于 32 个字段，通常复合索引中的字段不能包括哈希字段。
* Equality 和 Range 可以使用复合索引及复合索引前缀，且与字段升序和降序无关
* Sorting 可以使用复合索引及复合索引前缀，但与字段升序和降序有关
* 基于 ESR 模式创建复合索引

下载 people.json (链接: https://pan.baidu.com/s/1ZEbXIU3NXcToT5-xNQY83g 提取码: 3wvd) 导入到 MongoDB

[source, javascript]
----
$ mongoimport --host 127.0.0.1:27000 --db test --collection people --drop --file ~/Downloads/people.json
----

基于 link:basic.adoc[基础] 部分安装 Compass，使用 Compass 查看执行计划。

*1. 无索引下查看执行计划*

Compass 中查看 `db.people.find({last_name: "Frazier", first_name: "Jasmine"})` 操作的执行计划，会有如下图形化界面

image:img/compass-executionStats.png[]

*2. 创建单字段升序索引，查看执行计划*

Compass 中同样可以常见索引，例如如下

image:img/compass-create-single-indes-asd.png[]

如上创建了升序索引，名称为 last_name，在 Shell 中可以查看

[source, javascript]
----
> db.people.getIndexes()
[
	{
		"v" : 2,
		"key" : {
			"_id" : 1
		},
		"name" : "_id_",
		"ns" : "test.people"
	},
	{
		"v" : 2,
		"key" : {
			"last_name" : 1
		},
		"name" : "last_name",
		"ns" : "test.people"
	}
]
----

Compass 中查看 `db.people.find({last_name: "Frazier", first_name: "Jasmine"})` 操作的执行计划，会有如下图形化界面

image:img/compass-query-with-prefix-index.png[]

可以看到基于索引键查询。

*3. 创建复合升序索引，查看执行计划*

image:img/compass-compand-indexes.png[]

可以看到复合索引更能提高查询的性能。

NOTE: 复合索引下，range 范围查询，例如 `{last_name: "Frazier", first_name: {$gte : "L"}}` 等同样可以使用索引。

*4. 复合索引前缀*

复合索引前缀指的是复合索引从开始的一个子集，例如索引字段是

[source, javascript]
----
{ "job": 1, "last_name": 1, "first_name": 1 }
----

那么复合索引前缀是

[source, javascript]
----
{ job: 1 }
{ job: 1, last_name: 1 }
----

基于复合索引前缀查询同样可以使用索引，如下查询条件可以使用索引

[source, javascript]
----
{job: "Magazine features editor"}
{job: "Magazine features editor", last_name: "Ayers"}
{job: "Magazine features editor", last_name: "Ayers", first_name: "Mark"}
{first_name: "Mark", last_name: "Ayers", job: "Magazine features editor"}
----

如下查询可以部分使用索引

[source, javascript]
----
{job: "Magazine features editor", first_name: "Mark"}
----

如下查询条件不能够使用索引

[source, javascript]
----
{last_name: "Ayers"}
{last_name: "Ayers", first_name: "Mark"}
{first_name: "Mark"}
----

*5. 复合索引下升序和降序对排序是有影响的*

创建如下复合索引

[source, javascript]
----
{ "job": 1, "last_name": -1, "first_name": 1 }
----

升序和降序对查询没有影响，如下查询条件同样可以使用索引

[source, javascript]
----
{job: "Magazine features editor"} 
{job: "Magazine features editor", last_name: "Ayers"}
{job: "Magazine features editor", last_name: "Ayers", first_name: "Mark"}
----

使用如下排序可以使用索引,

[source, javascript]
----
{job: 1}
{job: -1}
{job: 1, last_name: -1}
{job: -1, last_name: 1}
{job: 1, last_name: -1, first_name: 1}
{job: -1, last_name: 1, first_name: -1}
----

如下排序不能使用索引

[source, javascript]
----
{job: 1, last_name: 1}
{job: -1, last_name: -1}
{job: 1, last_name: -1, first_name: -1}
{job: 1, last_name: 1, first_name: 1}
{job: -1, last_name: 1, first_name: 1}
{first_name: 1}
{first_name: -1}
{last_name: -1, first_name: 1}
----

==== 使用索引前缀查询

本部分创建复合索引 `{job: 1, employer: 1, last_name: 1, frist_name: 1}`，基于此索引进行查询。

[source, text]
.*1. 查看索引*
----
MongoDB Enterprise > db.people.getIndexes()
[
	{
		"v" : 2,
		"key" : {
			"_id" : 1
		},
		"name" : "_id_",
		"ns" : "m201.people"
	},
	{
		"v" : 2,
		"key" : {
			"job" : 1,
			"employer" : 1,
			"last_name" : 1,
			"frist_name" : 1
		},
		"name" : "job_1_employer_1_last_name_1_frist_name_1",
		"ns" : "m201.people"
	}
]
----

[source, text]
.*2. 依次执行下列查询，查看执行计划，并统计执行结果*
----
db.people.find({job: "Jewellery designer"}).explain("executionStats")
db.people.find({job: "Jewellery designer", employer: "Baldwin-Nichols"}).explain("executionStats")
db.people.find({job: "Jewellery designer", employer: "Baldwin-Nichols", last_name: "Cook"}).explain("executionStats")
db.people.find({job: "Jewellery designer", employer: "Baldwin-Nichols", last_name: "Cook", first_name: "Sara"}).explain("executionStats")
db.people.find({employer: "Baldwin-Nichols", last_name: "Cook", first_name: "Sara"}).explain("executionStats")
db.people.find({job: "Jewellery designer", first_name: "Sara",  last_name: "Cook"}).explain("executionStats")
----

统计结果

|===
|queryPlanner.winningPlan.stage |queryPlanner.winningPlan.inputStage |executionStats.nReturned |executionStats.totalKeysExamined |executionStats.totalDocsExamined

|FETCH
|IXSCAN
|83
|83
|83

|FETCH
|IXSCAN
|5
|5
|5

|FETCH
|IXSCAN
|1
|1
|1

|FETCH
|IXSCAN
|1
|1
|1

|COLLSCAN
|
|1
|0
|50474

|FETCH
|IXSCAN
|1
|74
|1
|===

==== 排序中使用复合索引属性

[source, text]
.*1. 查看索引*
----
MongoDB Enterprise > db.people.getIndexes()
[       
        {       
                "v" : 2,
                "key" : {
                        "_id" : 1
                },
                "name" : "_id_",
                "ns" : "m201.people"
        },      
        {       
                "v" : 2,
                "key" : {
                        "job" : 1, 
                        "employer" : 1,
                        "last_name" : 1,
                        "frist_name" : 1
                },
                "name" : "job_1_employer_1_last_name_1_frist_name_1",
                "ns" : "m201.people"
        }
]
----

[source, text]
.*2. 依次执行下列查询，查看执行计划，并统计执行结果*
----
db.people.find().sort({job: 1}).explain("executionStats")
db.people.find().sort({job: 1, employer: 1}).explain("executionStats")
db.people.find().sort({employer: 1}).explain("executionStats")
db.people.find({email: "jenniferfreeman@hotmail.com"}).sort({job: 1, employer: 1}).explain("executionStats")
db.people.find({job: "Jewellery designer", employer: "Baldwin-Nichols"}).sort({last_name: 1}).explain("executionStats")
db.people.find({job: "Jewellery designer", employer: "Baldwin-Nichols"}).sort({first_name: 1}).explain("executionStats")
----

统计结果

|===
|queryPlanner.winningPlan.stage |queryPlanner.winningPlan.inputStage

|FETCH
|IXSCAN

|FETCH
|IXSCAN

|SORT
|SORT_KEY_GENERATOR

|FETCH
|IXSCAN

|FETCH
|IXSCAN

|SORT
|SORT_KEY_GENERATOR
|===

==== 多 key 复合索引

如果一个 JSON 文档中嵌入了 Array 或 JSON 文档时，创建索引就可能是多 key 复合索引。

[source, text]
.*1. 准备数据*
----
db.products.insert({
  productName: "MongoDB Short Sleeve T-Shirt",
  categories: ["T-Shirts", "Clothing", "Apparel"],
  stock: { size: "L", color: "green", quantity: 100 }
});
----

[source, text]
.*2. 创建索引*
----
db.products.createIndex({ "stock.quantity": 1})
----

[source, text]
.*3. 执行查询，并查看执行计划*
----
MongoDB Enterprise > db.products.find({ "stock.quantity": 100 }).explain()
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "m201.products",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"stock.quantity" : {
				"$eq" : 100
			}
		},
		"winningPlan" : {
			"stage" : "FETCH",
			"inputStage" : {
				"stage" : "IXSCAN",
				"keyPattern" : {
					"stock.quantity" : 1
				},
				"indexName" : "stock.quantity_1",
				"isMultiKey" : false,
				"multiKeyPaths" : {
					"stock.quantity" : [ ]
				},
				"isUnique" : false,
				"isSparse" : false,
				"isPartial" : false,
				"indexVersion" : 2,
				"direction" : "forward",
				"indexBounds" : {
					"stock.quantity" : [
						"[100.0, 100.0]"
					]
				}
			}
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "m103",
		"port" : 27017,
		"version" : "3.6.11",
		"gitVersion" : "b4339db12bf57ffee5b84a95c6919dbd35fe31c9"
	},
	"ok" : 1
}
----

NOTE: 可以看到查询命中索引，IXSCAN 获取文档，isMultiKey 为 false。

[source, text]
.*4. 创建另外一条数据，quantity 在数组中*
----
db.products.insert({
  productName: "MongoDB Long Sleeve T-Shirt",
  categories: ["T-Shirts", "Clothing", "Apparel"],
  stock: [
    { size: "S", color: "red", quantity: 25 },
    { size: "S", color: "blue", quantity: 10 },
    { size: "M", color: "blue", quantity: 50 }
  ]
});
----

[source, text]
.*5. 执行查询，并查看执行计划*
----
MongoDB Enterprise > db.products.find({ "stock.quantity": 100 }).explain()
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "m201.products",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"stock.quantity" : {
				"$eq" : 100
			}
		},
		"winningPlan" : {
			"stage" : "FETCH",
			"inputStage" : {
				"stage" : "IXSCAN",
				"keyPattern" : {
					"stock.quantity" : 1
				},
				"indexName" : "stock.quantity_1",
				"isMultiKey" : true,
				"multiKeyPaths" : {
					"stock.quantity" : [
						"stock"
					]
				},
				"isUnique" : false,
				"isSparse" : false,
				"isPartial" : false,
				"indexVersion" : 2,
				"direction" : "forward",
				"indexBounds" : {
					"stock.quantity" : [
						"[100.0, 100.0]"
					]
				}
			}
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "m103",
		"port" : 27017,
		"version" : "3.6.11",
		"gitVersion" : "b4339db12bf57ffee5b84a95c6919dbd35fe31c9"
	},
	"ok" : 1
}
----

NOTE: 可以看到查询命中索引，IXSCAN 获取文档，isMultiKey 为 true，即只有嵌入的 key 在一个数组或文档中时，才触发了多 key 查询。

[source, text]
.*6. 创建一个多 key 复合索引*
----
MongoDB Enterprise > db.products.createIndex({ categories: 1, "stock.quantity": 1 })
{
	"ok" : 0,
	"errmsg" : "cannot index parallel arrays [stock] [categories]",
	"code" : 171,
	"codeName" : "CannotIndexParallelArrays"
}
----

NOTE: 如果两个 key 都属于嵌入的数组或文档，则索引创建失败。

[source, text]
.*7. 创建一个多 key 复合索引*
----
MongoDB Enterprise > db.products.createIndex({ productName: 1, "stock.quantity": 1 })
{
	"createdCollectionAutomatically" : false,
	"numIndexesBefore" : 2,
	"numIndexesAfter" : 3,
	"ok" : 1
}
----

[source, text]
.*8. 如果 stock 不是一个数组，productName 可以是一个数组*
----
MongoDB Enterprise > db.products.insert({productName: ["MongoDB Short Sleeve T-Shirt", "MongoDB Short Sleeve Shirt"], categories: ["T-Shirts", "Clothing", "Apparel"], stock: { size: "L", color: "green", quantity: 100 }});
WriteResult({ "nInserted" : 1 })
----

[source, text]
.*9. 如果 stock 和 productName 都是数组，则插入会失败*
----
MongoDB Enterprise > db.products.insert({productName: ["MongoDB Short Sleeve T-Shirt", "MongoDB Short Sleeve Shirt"], categories: ["T-Shirts", "Clothing", "Apparel"], stock: [{ size: "S", color: "red", quantity: 25 }, { size: "S", color: "blue", quantity: 10 }, { size: "M", color: "blue", quantity: 50 }]});
WriteResult({
	"nInserted" : 0,
	"writeError" : {
		"code" : 171,
		"errmsg" : "cannot index parallel arrays [stock] [productName]"
	}
})
----

=== Multikey 索引

为了更有效的支持数组类型的字段的查询，MongoDB 引入 Multikey 索引，创建语法：

[source, javascript]
----
db.coll.createIndex( { <field>: < 1 or -1 > } )
----

* 不能基于两个 Array 字段创建  Multikey 索引

[source, javascript]
.*1. 向 products 集合中添加一条记录*
----
db.products.insert({
  productName: "MongoDB Short Sleeve T-Shirt",
  categories: ["T-Shirts", "Clothing", "Apparel"],
  stock: { size: "L", color: "green", quantity: 100 }
});
----

[source, javascript]
.*2. 在 stock.quantity 上创建索引*
----
db.products.createIndex({ "stock.quantity": 1})
----

[source, javascript]
.*3. 查看执行计划*
----
var exp = db.products.explain()
exp.find({ "stock.quantity": 100 })
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "test.products",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"stock.quantity" : {
				"$eq" : 100
			}
		},
		"winningPlan" : {
			"stage" : "FETCH",
			"inputStage" : {
				"stage" : "IXSCAN",
				"keyPattern" : {
					"stock.quantity" : 1
				},
				"indexName" : "stock.quantity_1",
				"isMultiKey" : false,
				"multiKeyPaths" : {
					"stock.quantity" : [ ]
				},
				"isUnique" : false,
				"isSparse" : false,
				"isPartial" : false,
				"indexVersion" : 2,
				"direction" : "forward",
				"indexBounds" : {
					"stock.quantity" : [
						"[100.0, 100.0]"
					]
				}
			}
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "ksoong.local",
		"port" : 27017,
		"version" : "4.0.7",
		"gitVersion" : "1b82c812a9c0bbf6dc79d5400de9ea99e6ffa025"
	},
	"ok" : 1
}
----

NOTE: 注意，`winningPlan.inputStage.stage` 值为 IXSCAN，`winningPlan.inputStage.isMultiKey` 值为 false。

[source, javascript]
.*4. 向 products 集合中添加一条记录(stock 为 Array)*
----
  productName: "MongoDB Long Sleeve T-Shirt",
  categories: ["T-Shirts", "Clothing", "Apparel"],
  stock: [
    { size: "S", color: "red", quantity: 25 },
    { size: "S", color: "blue", quantity: 10 },
    { size: "M", color: "blue", quantity: 50 }
  ]
});
----

[source, javascript]
.*5. 查看执行计划*
----
exp.find({ "stock.quantity": 100 })
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "test.products",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"stock.quantity" : {
				"$eq" : 100
			}
		},
		"winningPlan" : {
			"stage" : "FETCH",
			"inputStage" : {
				"stage" : "IXSCAN",
				"keyPattern" : {
					"stock.quantity" : 1
				},
				"indexName" : "stock.quantity_1",
				"isMultiKey" : true,
				"multiKeyPaths" : {
					"stock.quantity" : [
						"stock"
					]
				},
				"isUnique" : false,
				"isSparse" : false,
				"isPartial" : false,
				"indexVersion" : 2,
				"direction" : "forward",
				"indexBounds" : {
					"stock.quantity" : [
						"[100.0, 100.0]"
					]
				}
			}
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "ksoong.local",
		"port" : 27017,
		"version" : "4.0.7",
		"gitVersion" : "1b82c812a9c0bbf6dc79d5400de9ea99e6ffa025"
	},
	"ok" : 1
}
----

NOTE: 注意，`winningPlan.inputStage.stage` 值为 IXSCAN，`winningPlan.inputStage.isMultiKey` 值为 true。

[source, javascript]
.*6. 在两个 ARRAY 字段上创建复合索引*
----
db.products.createIndex({ categories: 1, "stock.quantity": 1 })
{
	"ok" : 0,
	"errmsg" : "cannot index parallel arrays [stock] [categories]",
	"code" : 171,
	"codeName" : "CannotIndexParallelArrays"
}
----

[source, javascript]
.*7. 复合索引中只允许一个字段为 Array 字段*
----
db.products.createIndex({ productName: 1, "stock.quantity": 1 })
----

=== Partial 索引

Partial 索引只在符合某些条件的集合字段上创建索引。创建 Partial 索引语法：

[source, javascript]
----
db.<collection>.createIndex(
   { <field>: 1, <field>: 1 },
   { partialFilterExpression: { <field>: { $operator } } }
)
----

partialFilterExpression 支持的 operator 包括：

* $eq
* $exists: true 
* $gt, $gte, $lt, $lte 
* $type
* $and

如果要使用 Partial 索引，则查询条件中需要有 partialFilterExpression；Partial 索引不能和 sparse 索引一起使用；_id 字段或分片 Key 不能创建 Partial 索引。

[source, javascript]
.*1. 向 restaurants 中添加一条记录*
----
db.restaurants.insert({
   "name" : "Han Dynasty",
   "cuisine" : "Sichuan",
   "stars" : 4.4,
   "address" : {
      "street" : "90 3rd Ave",
      "city" : "New York",
      "state" : "NY",
      "zipcode" : "10003"
   }
});
----

[source, javascript]
.*2. 查看执行计划*
----
var exp = db.restaurants.explain()
exp.find({'address.city': 'New York', cuisine: 'Sichuan'})
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "test.restaurants",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"$and" : [
				{
					"address.city" : {
						"$eq" : "New York"
					}
				},
				{
					"cuisine" : {
						"$eq" : "Sichuan"
					}
				}
			]
		},
		"winningPlan" : {
			"stage" : "COLLSCAN",
			"filter" : {
				"$and" : [
					{
						"address.city" : {
							"$eq" : "New York"
						}
					},
					{
						"cuisine" : {
							"$eq" : "Sichuan"
						}
					}
				]
			},
			"direction" : "forward"
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "ksoong.local",
		"port" : 27017,
		"version" : "4.0.7",
		"gitVersion" : "1b82c812a9c0bbf6dc79d5400de9ea99e6ffa025"
	},
	"ok" : 1
}
----

[source, javascript]
.*3. 创建 Partial 索引*
----
db.restaurants.createIndex(
  { "address.city": 1, cuisine: 1 },
  { partialFilterExpression: { 'stars': { $gte: 3.5 } } }
)
----

[source, javascript]
.*4. 查看执行计划*
----
exp.find({'address.city': 'New York', cuisine: 'Sichuan', stars: { $gt: 4.0 }})
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "test.restaurants",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"$and" : [
				{
					"address.city" : {
						"$eq" : "New York"
					}
				},
				{
					"cuisine" : {
						"$eq" : "Sichuan"
					}
				},
				{
					"stars" : {
						"$gt" : 4
					}
				}
			]
		},
		"winningPlan" : {
			"stage" : "FETCH",
			"filter" : {
				"stars" : {
					"$gt" : 4
				}
			},
			"inputStage" : {
				"stage" : "IXSCAN",
				"keyPattern" : {
					"address.city" : 1,
					"cuisine" : 1
				},
				"indexName" : "address.city_1_cuisine_1",
				"isMultiKey" : false,
				"multiKeyPaths" : {
					"address.city" : [ ],
					"cuisine" : [ ]
				},
				"isUnique" : false,
				"isSparse" : false,
				"isPartial" : true,
				"indexVersion" : 2,
				"direction" : "forward",
				"indexBounds" : {
					"address.city" : [
						"[\"New York\", \"New York\"]"
					],
					"cuisine" : [
						"[\"Sichuan\", \"Sichuan\"]"
					]
				}
			}
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "ksoong.local",
		"port" : 27017,
		"version" : "4.0.7",
		"gitVersion" : "1b82c812a9c0bbf6dc79d5400de9ea99e6ffa025"
	},
	"ok" : 1
}
----

NOET: 注意，`winningPlan.inputStage.stage` 值为 IXSCAN，`winningPlan.inputStage.isPartial` 值为 true。

[source, javascript]
.*5. 使用不同的过滤条件，查看执行计划*
----
 exp.find({'address.city': 'New York', cuisine: 'Sichuan', stars: { $gt: 2.0 }})
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "test.restaurants",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"$and" : [
				{
					"address.city" : {
						"$eq" : "New York"
					}
				},
				{
					"cuisine" : {
						"$eq" : "Sichuan"
					}
				},
				{
					"stars" : {
						"$gt" : 2
					}
				}
			]
		},
		"winningPlan" : {
			"stage" : "COLLSCAN",
			"filter" : {
				"$and" : [
					{
						"address.city" : {
							"$eq" : "New York"
						}
					},
					{
						"cuisine" : {
							"$eq" : "Sichuan"
						}
					},
					{
						"stars" : {
							"$gt" : 2
						}
					}
				]
			},
			"direction" : "forward"
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "ksoong.local",
		"port" : 27017,
		"version" : "4.0.7",
		"gitVersion" : "1b82c812a9c0bbf6dc79d5400de9ea99e6ffa025"
	},
	"ok" : 1
}
----

NOTE: 注意，没有执行没有使用索引。

=== Text 索引

Text 索引用来支持文本搜索，创建语法

[source, javascript]
----
db.<collection>.createIndex( { <field>: "text", <field>: "text" , ... } )
----

* Text 索引可以创建到任意文本字段（String 类型），不管该字段是文档的字段或数组字段
* 一个文档中可创建多个 Text 索引
* 复合索引中可以使用 Text 索引

[source, javascript]
.*1. 向 textExample 集合中添加 2 条记录*
----
db.textExample.insertOne({ "statement": "MongoDB is the best" })
db.textExample.insertOne({ "statement": "MongoDB is the worst." })
----

[source, javascript]
.*2. 创建索引*
----
db.textExample.createIndex({ statement: "text" })
----

[source, javascript]
.*3. 查看执行计划*
----
db.textExample.find({ $text: { $search: "MongoDB best" } }).explain()
{
	"queryPlanner" : {
		"plannerVersion" : 1,
		"namespace" : "test.textExample",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"$text" : {
				"$search" : "MongoDB best",
				"$language" : "english",
				"$caseSensitive" : false,
				"$diacriticSensitive" : false
			}
		},
		"winningPlan" : {
			"stage" : "TEXT",
			"indexPrefix" : {
				
			},
			"indexName" : "statement_text",
			"parsedTextQuery" : {
				"terms" : [
					"best",
					"mongodb"
				],
				"negatedTerms" : [ ],
				"phrases" : [ ],
				"negatedPhrases" : [ ]
			},
			"textIndexVersion" : 3,
			"inputStage" : {
				"stage" : "TEXT_MATCH",
				"inputStage" : {
					"stage" : "FETCH",
					"inputStage" : {
						"stage" : "OR",
						"inputStages" : [
							{
								"stage" : "IXSCAN",
								"keyPattern" : {
									"_fts" : "text",
									"_ftsx" : 1
								},
								"indexName" : "statement_text",
								"isMultiKey" : true,
								"isUnique" : false,
								"isSparse" : false,
								"isPartial" : false,
								"indexVersion" : 2,
								"direction" : "backward",
								"indexBounds" : {
									
								}
							},
							{
								"stage" : "IXSCAN",
								"keyPattern" : {
									"_fts" : "text",
									"_ftsx" : 1
								},
								"indexName" : "statement_text",
								"isMultiKey" : true,
								"isUnique" : false,
								"isSparse" : false,
								"isPartial" : false,
								"indexVersion" : 2,
								"direction" : "backward",
								"indexBounds" : {
									
								}
							}
						]
					}
				}
			}
		},
		"rejectedPlans" : [ ]
	},
	"serverInfo" : {
		"host" : "ksoong.local",
		"port" : 27017,
		"version" : "4.0.7",
		"gitVersion" : "1b82c812a9c0bbf6dc79d5400de9ea99e6ffa025"
	},
	"ok" : 1
}
----

=== TODO

[source, javascript]
----

----

[source, javascript]
----

----

[source, javascript]
----

----

== OLD

=== 数据导入

[source, text]
.*1. 导入数据*
----
$ mongoimport --db m201 --username root --password mongodb --authenticationDatabase admin --file /shared/restaurants.json
2019-04-05T13:28:45.088+0000	no collection specified
2019-04-05T13:28:45.088+0000	using filename 'restaurants' as collection
2019-04-05T13:28:45.100+0000	connected to: localhost
2019-04-05T13:28:48.090+0000	[###.....................] m201.restaurants	23.6MB/144MB (16.4%)
2019-04-05T13:28:51.090+0000	[#######.................] m201.restaurants	46.6MB/144MB (32.4%)
2019-04-05T13:28:54.090+0000	[###########.............] m201.restaurants	69.4MB/144MB (48.3%)
2019-04-05T13:28:57.090+0000	[###############.........] m201.restaurants	91.8MB/144MB (63.9%)
2019-04-05T13:29:00.090+0000	[###################.....] m201.restaurants	115MB/144MB (79.9%)
2019-04-05T13:29:03.090+0000	[#######################.] m201.restaurants	138MB/144MB (96.1%)
2019-04-05T13:29:03.798+0000	[########################] m201.restaurants	144MB/144MB (100.0%)
2019-04-05T13:29:03.799+0000	imported 1000000 documents
----

[source, text]
.*2. mongo shell 登录并查看数据*
----
$ mongo --username root --password mongodb --authenticationDatabase admin
MongoDB shell version v3.6.11
connecting to: mongodb://127.0.0.1:27017/?authSource=admin&gssapiServiceName=mongodb
Implicit session: session { "id" : UUID("fa203fbf-c07a-47ad-8c5c-126dad5b0146") }
MongoDB server version: 3.6.11

MongoDB Enterprise > use m201
switched to db m201

MongoDB Enterprise > db.restaurants.count()
1000000

MongoDB Enterprise > db.restaurants.findOne()
{
	"_id" : ObjectId("5ca7580df8858899e8a535ab"),
	"name" : "Perry Street Brasserie",
	"cuisine" : "French",
	"stars" : 0.3,
	"address" : {
		"street" : "959 Iveno Square",
		"city" : "Fokemlid",
		"state" : "AL",
		"zipcode" : "18882"
	}
}
----

=== 创建 background 索引

[source, text]
.*1. 创建 background 索引*
----
MongoDB Enterprise > db.restaurants.createIndex({cuisine: 1, name: 1, "address.zipcode": 1}, {background: true})
{
	"createdCollectionAutomatically" : false,
	"numIndexesBefore" : 1,
	"numIndexesAfter" : 2,
	"ok" : 1
}
----

[source, text]
.*2. 查看创建的索引*
----
MongoDB Enterprise > db.restaurants.getIndexes()
[
	{
		"v" : 2,
		"key" : {
			"_id" : 1
		},
		"name" : "_id_",
		"ns" : "m201.restaurants"
	},
	{
		"v" : 2,
		"key" : {
			"cuisine" : 1,
			"name" : 1,
			"address.zipcode" : 1
		},
		"name" : "cuisine_1_name_1_address.zipcode_1",
		"ns" : "m201.restaurants",
		"background" : true
	}
]
----

== TODO

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----

[source, text]
.**
----

----



